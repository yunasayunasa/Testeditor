Odyssey Engine v3.0 - Internal Architecture Specification (FINAL REVISION)
Document ID: OE-IAS-3.0-FINAL-R1
Version: 3.0 Revision 1 (Final)
Classification: GEMINI_INTERNAL_SPEC_COMPLETE
Objective: To provide a definitive, logically-structured, and comprehensive model of the Odyssey Engine's architecture, data flow, and core protocols. This document incorporates the evolution to a Dual Architecture Model (Scenario-Driven and Data-Driven) and the integration of the In-Game Editor (IDE Mode). It supersedes all previous versions.
SECTION 1: SYSTEM ARCHITECTURE & LIFECYCLE
1.1. Core Principle: Dual Architecture & Centralized Mediation
The system has evolved into a Dual Architecture model to support both narrative-heavy and gameplay-heavy scenes, while retaining the core Mediator pattern.
Scenario-Driven Scenes (e.g., GameScene): The primary state and flow are controlled by the ScenarioManager interpreting .ks files. These scenes are stateful and optimized for complex narrative branching and persistence.
Data-Driven Scenes (e.g., JumpScene, future scenes inheriting from BaseGameScene): The initial state, object layout, and physical properties are defined by external .json data files. These scenes are designed for gameplay mechanics (action, puzzles) and are primarily managed through the in-game editor.
SystemScene remains the central mediator, orchestrating all scene transitions. StateManager remains the Single Source of Truth for game variables.
1.2. Service Locator & Instantiation Locus (ADDENDUM)
A new set of services related to the In-Game Editor (IDE Mode) is introduced.
Service	Class	Initialization Locus	Registry Key	Criticality	Description
Editor Plugin	EditorPlugin	main.js (config) & SystemScene.create	editor	High (Debug)	The core controller for all in-game editing functionalities. Manages object selection, property modification, and editable object registration. It is a Phaser Global Plugin.
Editor UI	EditorUI	SystemScene.create	N/A	High (Debug)	A pure HTML/CSS/JS controller, completely decoupled from Phaser's scene graph. Manages all DOM elements of the editor (panels, buttons, asset browser) and communicates user actions to the EditorPlugin.
Global Asset List	Array	PreloadScene.create	asset_list	Medium	A comprehensive list of all loaded assets (key, type, path), used by the EditorUI's asset browser.
1.3. Scene Roles & Responsibilities (REVISED)
PreloadScene: (Responsibilities updated)
Comprehensive Asset Loading: Loads asset_define.json and, based on its contents, queues all game assets, including individual files and dynamically sourced folder contents (scenarios, scene data JSONs), for a single, comprehensive load operation.
Global Asset List Generation: On load.complete, generates the asset_list and registers it to the Phaser.Registry.
(Other responsibilities remain unchanged)
SystemScene: (Responsibilities updated)
IDE Mode Activation: Checks for the ?debug=true URL parameter. If present, it starts the EditorPlugin and instantiates the EditorUI, establishing the link between them.
(Other responsibilities remain unchanged)
UIScene: (No architectural change, but clarification)
UIScene is a Scenario-Driven scene, but its content is primarily hard-coded within its create method for stability. It can, however, have its layout overridden by a corresponding UIScene.json if the layout application logic is implemented. MessageWindows are now considered part of the GameScene's responsibility, with UIScene ensuring other UI elements render correctly around it by managing depth.
GameScene: (Role clarified)
Represents the canonical Scenario-Driven scene type. Its object lifecycle (chara_show, bg) is dictated by the flow of the .ks script. It does not inherit from BaseGameScene. It is a self-contained, highly specialized system for narrative delivery.
BaseGameScene (NEW):
Purpose: The abstract base class for all Data-Driven scenes. It provides the core logic for loading a scene-specific .json file and using it to build the scene's content.
Lifecycle: A scene inheriting from this class (e.g., JumpScene) must call this.initSceneWithData() within its create method.
Core Methods:
initSceneWithData(): The entry point. Reads the corresponding .json from cache.
buildSceneFromLayout(): Parses the JSON and orchestrates object creation and property application in a safe, two-pass process (create all -> apply all) to prevent race conditions.
createObjectFromLayout(): A virtual method intended to be overridden by child scenes to handle the creation of scene-specific object types.
applyProperties(): Applies transform, physics, and other component data from the JSON to a newly created GameObject. Also responsible for registering the object with the EditorPlugin.
addObjectFromEditor(): A virtual method that defines the scene's specific protocol for handling new objects added via the editor's "Add Asset" button.
finalizeSetup(): The final step in the creation lifecycle, responsible for calling scene-specific setup (onSetupComplete) and emitting the scene-ready event.
SECTION 2: SCENARIO EXECUTION ENGINE (ScenarioManager.js)
(No fundamental changes to the core loop. This section remains valid for GameScene.)
SECTION 3: SCENE TRANSITION & PERSISTENCE PROTOCOL
3.1. Scene Transition Protocol (REVISED)
The protocol remains mediated by SystemScene, but the handshake mechanism is now standardized.
Handshake Protocol:
GameScene: Emits the specific gameScene-load-complete event on completion of its complex create or performLoad methods.
All other scenes (especially BaseGameScene children): Emit the generic scene-ready event upon completion of their setup (typically at the end of finalizeSetup).
SystemScene._startAndMonitorScene: Correctly listens for the appropriate event based on the sceneKey.
Transition Flow Amendment (_handleRequestSceneTransition): To prevent race conditions between a scene shutting down and a new one starting, the flow is now event-based.
_handleRequestSceneTransition receives a request.
It registers a once listener for the shutdown event of the from scene.
It calls this.scene.stop(from).
Only within the shutdown event's callback does it proceed to call _startAndMonitorScene for the to scene. This guarantees the old scene is completely gone before the new one begins its lifecycle.
SECTION 4: IN-GAME EDITOR (IDE MODE) PROTOCOLS (NEW SECTION)
4.1. Core Principle: Decoupled MVC-like Pattern
The editor operates on a pattern resembling Model-View-Controller, completely decoupled from the game's core logic.
Model: The game's scene graph (the GameObject instances and their properties) is the model.
View: The HTML/CSS panels (#editor-panel, #asset-browser) are the view.
Controller: A dual-controller system:
EditorPlugin: The primary controller acting on the Model (Phaser world). It directly manipulates GameObjects.
EditorUI: The secondary controller acting on the View (HTML world). It listens for DOM events and translates them into commands for the EditorPlugin or the active scene.
4.2. Object Creation & Registration Protocol (Definitive)
This protocol unifies object creation from all sources (JSON, D&D, scenario tags) for editor compatibility.
Instantiation: An object is created, either by scene.add.image (GameScene, scenario tags) or new Phaser.GameObjects.Image (BaseGameScene, EditorUI).
Naming: A unique name property MUST be assigned to the GameObject. This is the primary key for layout persistence and editor selection.
Registration: The object MUST be passed to the EditorPlugin's makeEditable(gameObject, scene) method.
makeEditable is idempotent; it performs the initial setup (setInteractive, event listeners) only once per object.
Crucially, it adds/updates the object's reference in the editableObjects map, ensuring its properties are correctly exported.
4.3. Data Persistence Protocol (Editor I/O)
Export (exportLayoutToJson):
Trigger: User clicks the "Export" button in the property panel.
Source Scene: Determined by this.selectedObject.scene.
Source Data: The editableObjects map for the corresponding sceneKey.
Process: Iterates through the registered GameObject set for that scene, serializing key component data (Transform, Physics) into a JSON structure.
Output: The generated JSON string is logged to the console and copied to the user's clipboard.
Import (Layout Application):
Locus: BaseGameScene.initSceneWithData() for data-driven scenes. GameScene.create() contains a custom implementation for its specific needs.
Trigger: Scene creation.
Source Data: The .json file corresponding to the sceneKey, pre-loaded by PreloadScene.
Process: The scene reads the JSON objects array. For each entry, it instantiates the corresponding GameObject and applies the stored component properties. It then ensures the object is registered with the editor via the Registration Protocol (4.2).
SECTION 5: DEVELOPMENT & EXTENSION CONTRACTS (REVISED)
5.1. Contract: Adding a New Data-Driven Scene
This supersedes the old "New Game Scene" contract for any non-narrative scene.
Inherit BaseGameScene: The class MUST extend BaseGameScene.
Call initSceneWithData: The create() method MUST call this.initSceneWithData() to trigger the data-driven setup process.
Implement addObjectFromEditor: To support the editor's "Add Asset" button, the scene MUST implement the addObjectFromEditor(assetKey, newName) method. This method is responsible for instantiating a new object and passing it to a setup routine like applyProperties.
Use onSetupComplete for Post-Layout Logic: Any logic that depends on all objects being present and configured (e.g., setting up physics colliders) MUST be placed in an onSetupComplete() method.
Adhere to Core Contracts: The universal rules of BGM playback (create), scene termination (return-to-novel), and resource cleanup (shutdown) remain in effect.
END OF DOCUMENT
Use Arrow Up and Arrow Down to select a turn, Enter to jump to it, and Escape to return to the chat.
