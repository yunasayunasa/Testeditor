Odyssey Engine v5.10 - ユーザーマニュアル (最終確定・完成版)
1. はじめに：これは、あなたの「世界」のためのエンジンです
Odyssey Engineへようこそ。
このエンジンは、単なるツールではありません。私達が共にたどり着いた**「安定した世界の器」**です。Phaser 3が持つパワフルな表現力と、ティラノスクリプトのような直感的な記述法。この二つを融合させ、ノベルゲームと他のジャンルを組み合わせた「ハイブリッドゲーム」を、誰もが創造できる世界を目指して生まれ変わりました。
このマニュアルは、その旅路に立つあなたのための、唯一無二の羅針盤です。

2. エンジンの設計思想：なぜ、こうなっているのか
このエンジンは、いくつかの強力な柱によって支えられています。

中央集権的なシーン管理 (SystemScene): シーン遷移という不安定になりがちな処理を、司令塔であるSystemSceneに一任。あなたは「このシーンへ行け」と命令するだけで、エンジンが安全な遷移を保証します。
イベント駆動の状態管理 (StateManager): HPが減る、フラグが立つ。そういったゲーム内の「出来事」は、すべてStateManagerという唯一の状態管理者が記録します。UIやゲームロジックは、その変化を「聞く」だけで自動的に更新されます。
【v3.0】データ駆動によるシーン構築: アクションやパズルなど、ノベル以外のゲームシーンは、.jsonファイルによってその**初期レイアウト（オブジェクトの配置、物理特性など）**を定義します。これにより、コードを触ることなく、ステージの設計をデータとして管理・編集できます。
【v3.0】インゲーム・エディタによる開発支援: デバッグモードで起動することで、ゲーム画面そのものが統合開発環境 (IDE) となります。アセットの配置から、オブジェクトのプロパティ調整、レイアウトデータの出力までを、視覚的かつ直感的に行うことができます。
3. ゲーム制作の2つのモード
Odyssey Engine v3.0でのゲーム制作は、主に2つのモードで行われます。

3.1. シナリオモード (GameScene / .ksファイル)
伝統的なノベルゲームのパートです。物語、キャラクターの会話、基本的な演出は、これまで通り.ksという拡張子のテキストファイルに記述します。

3. シナリオ入門：物語を記述する (.ksファイル)
ゲームの物語、演出、キャラクターの動きは、すべて.ksという拡張子のテキストファイルに記述します。

3.1. シナリオの基本構造
要素	書き方	役割
テキスト	テキストをそのまま記述	メッセージウィンドウに文章を表示（地の文）
セリフ	キャラクター名: テキスト	話者付きでセリフを表示
タグ	[タグ名 パラメータ=値]	演出、分岐、シーン遷移などの特殊な命令
ラベル	*ラベル名	[jump]や[link]のジャンプ先となる目印
コメント	; で始まる行	実行時に無視されるメモ
アセット宣言	@asset type=image key=... path=...	このシナリオで使うアセットを、シナリオ開始時に動的に読み込む
シナリオの例:

Generated text
; これはゲームに影響しないコメントです

; ▼ このシナリオで使うアセットを宣言します
@asset type=image key=bg_school path=backgrounds/school_day.png
@asset type=image key=yuko_smile path=characters/yuko_smile.png

*start
; 演出タグは連続で実行され、クリックを待ちません
[bg storage=bg_school]
[chara_show name=yuko storage=yuko_smile pos=center]

; テキストも、[p]タグが来るまでは止まりません
yuko:「こんにちは、世界！」
yuko:「これがOdyssey Engineよ！」

; [p]タグで、初めてクリックを待って改ページします
[p]

; [br]タグは、同じウィンドウの中で改行します
yuko:「とっても簡単でしょ？[br]さあ、始めましょう！」
[p]
[s]

content_copy

download
Use code with caution.
Text
3.2. テキストと改ページ・改行のルール
Odyssey Engineのテキスト制御は、非常にシンプルで強力なルールに基づいています。

タグ	役割	実行後の状態
[br]	文中改行 (Break)	同じメッセージ内で改行。シナリオは停止せず、処理を続行。
[p]	改ページ (Page Break / Pause)	クリック待ちになる。クリックされるとウィンドウがクリアされ、次の行へ。
(テキスト行)	文字表示	メッセージウィンドウに文字を表示するだけ。シナリオは停止しない。
このルールにより、**「演出タグを連続で実行し、最後に[p]で待つ」**といった、テンポの良いシナリオ記述が可能になります。

4. 変数について
Odyssey Engineには2種類の変数があり、ゲームの状態を記憶します。

ゲーム変数 (f.): 好感度、フラグ、所持金など、セーブデータに含まれる変数。
例: f.love_meter, f.item_get_flag
システム変数 (sf.): 既読管理、各種設定など、セーブデータとは別にゲーム全体で共有される変数。
例: sf.config_text_speed
変数の操作は、主に[eval]タグと[if]タグで行います。変数の値をテキスト中に表示するには &f.変数名 のように記述します。

5. タグ・リファレンス
タグはエンジンの力の源です。パラメータは 属性=値 の形式で、半角スペースで区切って複数指定できます。値にスペースを含みたい場合は " (ダブルクォート) で囲ってください。

カテゴリ: フロー制御
物語の流れを自在にコントロールします。

<details>
<summary><strong><code>[p]</code>, <code>[link]</code>, <code>[r]</code>, <code>[s]</code> - 待機と選択肢</strong></summary>
[p]: 改ページ（クリック待ち）
シナリオの進行を一時停止し、プレイヤーのクリックを待ちます。クリックされると、メッセージウィンドウがクリアされ、次の行の処理に進みます。テキストの区切りで最もよく使うタグです。
[link], [r], [s]: 選択肢の基本セット
この3つのタグはセットで使います。プレイヤーに選択を促すためのフローです。
[link text="ボタンの文字" target="*ジャンプ先"]: 選択肢を定義します。この時点では画面に表示されません。
[r] (Render): [link]で定義された選択肢を画面に表示します。
[s] (Stop): シナリオの進行を停止し、プレイヤーが選択肢をクリックするのを待ちます。
使用例:
Generated text
yuko:「今日はどこへ行く？」[p]

; 選択肢を定義
[link text="公園" target="*park"]
[link text="図書館" target="*library"]

; [r]で選択肢を表示する
[r]
; [s]でプレイヤーの選択を待つ。必須！
[s]

*park
; 公園のシナリオ...
[jump target="*common_route"]

content_copy

download
Use code with caution.
Text
</details>
<details>
<summary><strong><code>[if]</code>, <code>[jump]</code>, <code>[call]</code> - 分岐と遷移</strong></summary>
[if], [elsif], [else], [endif]: 条件分岐
変数の値に応じて、シナリオの実行内容を分岐させます。
[if exp="条件式"]: 条件式が真(true)の場合に実行。
条件式はJavaScriptの構文です。例: f.love >= 10, f.flag === true
[endif]で分岐の終わりを必ず示してください。
[jump]: ジャンプ
戻ってくることを想定しない、一方通行の移動です。現在のシナリオ実行を終了し、指定された場所へ移動します。
target="*ラベル名": 同じファイル内のラベルへ移動。
storage="SceneKey": 別のPhaserシーン（バトル、パズルなど）へ遷移。
params="{...}": storage指定時、遷移先のシーンに変数を渡せます。
[call], [return]: サブルーチン
一時的に別の場所の処理を呼び出し、終わったら元の場所に戻ってくる機能です。共通のイベントなどを部品化するのに便利です。
[call]で target や storage を指定して呼び出し、サブルーチンの最後に[return]を記述します。
</details>
カテゴリ: キャラクター・画像
画面を華やかに彩ります。

<details>
<summary><strong>主要な画像操作タグ</strong></summary>
[chara_show]: キャラクターを表示します。
name (必須): キャラクターの管理名。セリフの話者名と一致させます。
storage (必須): アセットの画像キー。
pos: left, center, rightから選択。x, yでの座標指定も可能。
time: フェードイン時間（ミリ秒）。
nowait="true": アニメーションの完了を待たずに次の処理へ進みます。
[chara_mod]: 表示中のキャラクターの画像を差し替えます。（表情差分など）
name (必須): 対象キャラクターのname。
storage (必須): 新しい画像キー。
time: クロスフェードの時間（ミリ秒）。
[chara_hide]: キャラクターを消去します。
name (必須): 対象キャラクターのname。
time: フェードアウト時間（ミリ秒）。
[bg]: 背景を表示します。
storage (必須): 画像キー。
time: フェードイン/クロスフェードの時間（ミリ秒）。
[image] / [freeimage]: CGなどの前景画像を表示・消去します。chara_showと似たパラメータが使えます。
</details>
カテゴリ: 演出・音声
ゲーム体験を豊かにします。

<details>
<summary><strong>主要な演出・音声タグ</strong></summary>
[shake]: 画面を揺らします。
time (必須): 揺れる時間（ミリ秒）。
power: 揺れの強さ。
[flash]: 画面を特定の色で一瞬光らせます。
color: 0xffffff（白）のような16進数カラーコード。
time: フラッシュの時間。
[playbgm] / [stopbgm]: BGMの再生と停止。
storage (必須): BGMのキー。
loop: true (デフォルト) or false。
[stopbgm]では time でフェードアウト時間を指定できます。
[playse]: 効果音を再生します。
</details>
カテゴリ: 変数操作・その他
<details>
<summary><strong>主要なユーティリティタグ</strong></summary>
[eval]: ゲーム変数(f.)やシステム変数(sf.)の値を直接操作する、非常に強力なタグです。
exp (必須): 実行するJavaScript式を記述します。
例: [eval exp="f.love = f.love + 10"]
[wait]: 指定時間、処理を待ちます。
time (必須): 待機する時間（ミリ秒）。1000で1秒。
[hidewindow] / [showwindow]: メッセージウィンドウを非表示/表示します。
</details>
6. ゲームの拡張（プログラマー向け）
このセクションは、エンジンに新しい機能を追加したい開発者向けの技術情報です。

6.1. 新規タグの追加
src/handlers/にハンドラファイル (new_tag.jsなど) を作成します。
src/handlers/index.jsを開き、作成したファイルをimportし、tagHandlersオブジェクトに1行追加します。
これだけで、エンジンは新しいタグを自動的に認識します。GameScene.jsを触る必要はありません。
6.2. ⭐【最重要】新規ゲームシーン開発の規約⭐
Odyssey Engineで、ノベルパートから遷移する新しいゲームシーン（アクション、パズルなど）を作る際は、以下のルールを必ず守ってください。これは、エンジン全体の安定性を保つための契約です。
【全ての新規シーンに共通の5ヶ条】
create()の最後にscene-readyを発行する
シーンの準備がすべて完了した最後に、必ずthis.events.emit('scene-ready');を記述します。これがSystemSceneへの「準備完了」の合図です。
BGMはcreate()で再生する
シーンが始まったら、this.soundManager.playBgm('曲名');でBGMの再生を「命令」するだけです。SoundManagerが前の曲を賢く止めてくれます。
ノベルシーンへの復帰はSystemSceneに依頼する
シーンを終了する際は、必ずthis.scene.get('SystemScene').events.emit('return-to-novel', ...)を発行します。自身のstop()は絶対に呼ばないでください。
shutdown()で後片付けをする
shutdown()メソッドを実装し、そのシーンのcreate()で生成したタイマー (this.time.addEvent) やイベントリスナー (this.events.on) は、必ずここで破棄・解除してください。
HUDは操作しない
シーンの中からHPバーを直接操作しようとしないでください。代わりにthis.stateManager.setF('player_hp', 50);のように状態変数を変更します。UIの更新はUISceneとHUD自身が自動的に行います。

第1条：自己申告の原則 (The Principle of Self-Declaration)
UIコンポーネントは、自身が依存するゲーム変数(f.)を、static dependenciesプロパティとして必ずクラス内に明記しなければならない。これにより、エンジンは起動時に依存関係を自動的に解決し、watchリストを構築する。

記述例 (HpBar.js):

code
JavaScript
export default class HpBar extends Phaser.GameObjects.Container {
    // このクラスは f.player_hp と f.player_max_hp の変化を監視することを宣言する
    static dependencies = ['player_hp', 'player_max_hp'];

    // ... constructor ...
}
この申告により、あなたはuiRegistryファイルにwatchプロパティを手で記述する手間から解放される。

第2条：更新メソッドの実装義務 (The Obligation to Implement updateValue)
dependenciesを申告したUIコンポーネントは、updateValue(state)という名前のpublicメソッドを必ず実装しなければならない。このメソッドは、UISceneから呼び出される唯一の公式な窓口である。

仕様:

引数 state: StateManagerが保持する現在のゲーム変数オブジェクト (f) 全体が渡される。
責務: stateオブジェクトの中から、dependenciesで申告したキー（例: state.player_hp）を自身で取り出し、自身の表示（バーの長さ、テキストなど）を更新する。
実装例 (HpBar.js):

code
JavaScript
updateValue(state) {
        const currentHp = state.player_hp || 0;
        const maxHp = state.player_max_hp || 100;

        // ... この値を使ってバーの幅やテキストを更新する処理 ...
    }
第3条：StateManagerへの非干渉 (Non-Interference with StateManager)
UIコンポーネントは、StateManagerの状態を直接購読してはならない (stateManager.on(...)の禁止)。状態変更の検知と通知は、GameSceneとUISceneから成る中央管理システムが一括して行う。コンポーネントの役割は、updateValueメソッドを通じて命令を受け取り、自身の見た目を更新することに限定される。

これにより、イベントリスナーの登録漏れや解除忘れによるメモリリークを構造的に防止し、データの流れを常に一方向（StateManager → UIScene → Component）に保つ。
【データ駆動シーンのための追加規約】
BaseGameSceneを継承する
新しいデータ駆動シーンは、import BaseGameScene from './BaseGameScene.js'; を行い、export default class YourScene extends BaseGameScene としてクラスを定義します。これにより、シーンはエディタ連携とデータ駆動の全ての恩恵を自動的に受け継ぎます。
createでinitSceneWithDataを呼ぶ
create()の中でthis.initSceneWithData()を呼び出すことで、対応する.jsonファイル（例: YourScene.json）が自動で読み込まれ、シーンが構築されます。
オブジェクトの追加はaddObjectFromEditorを実装する
エディタの「追加ボタン」に応答するために、このメソッドをオーバーライドしてください。親クラス（BaseGameScene）の力を借りることで、安全なオブジェクト生成とエディタへの登録が保証されます。
6.3. インゲーム・エディタの使い方
URLの末尾に ?debug=true&edit を付けてゲームを起動すると、IDEモードになります。
アセット・ブラウザ:
利用可能な画像アセットを一覧表示します。アセットを選択し、**「Add Selected Asset to Scene」**ボタンを押すことで、現在アクティブなデータ駆動シーンにオブジェクトを追加できます。
プロパティパネル:
シーン上のオブジェクトを選択すると、そのプロパティ（Name, Transform, Physics）をリアルタイムに編集できます。
Export Layout: 編集中のシーンの現在のレイアウトを、対応する.jsonファイル形式でクリップボードにコピーします。コピーした内容を、assets/data/scenes/フォルダ内の対応するJSONファイルに貼り付けて保存することで、変更が永続化されます。
Delete Object: 選択中のオブジェクトをシーンから完全に削除します。

6.3. 動的アセットロード (@asset)
大規模なゲームでは、最初にすべてのアセットを読み込むと起動が遅くなります。@assetを使うと、そのシナリオが必要とするアセットだけを、シナリオ開始直前に自動で読み込ませることができます。

書式: @asset type="種類" key="管理キー" path="ファイルパス"
配置場所: シナリオファイルの先頭（ラベルや地の文より前）に記述してください。

** 【重要！】** IDEモード (データ駆動シーン / インゲーム・エディタ)
アクション、パズル、探索など、インタラクティブなゲームプレイ部分を構築するための新しいモードです。ここでは、コードやシナリオの代わりに、ゲーム画面上で直接オブジェクトを配置し、設定を調整していきます。

** 【重要！】**新規ゲームシーンの作り方
「JumpScene.js は、BaseGameScene を継承したお手本です。新しいゲームシーンを作る際は、この JumpScene.js をコピーして、クラス名を変更することから始めましょう。」

** 【重要！】**エディタモードの起動方法
ゲームのURLの末尾に ?debug=true を付けて起動します。

レイヤーパネル (Layers)
シーンを「前景(Foreground)」「ゲームプレイ(Gameplay)」「背景(Background)」などの層に分けて管理します。
👁️アイコンでレイヤーの表示/非表示、🔒アイコンでレイヤー上のオブジェクトの選択をロックできます。
オブジェクトは、プロパティパネルで所属するレイヤーを変更できます。
アセットブラウザ (Asset Browser)
ゲームに読み込まれている全てのアセット（画像、プレハブなど）を一覧表示します。
アセットを選択し、**「選択したアセットを追加」**ボタンを押すと、現在アクティブなレイヤーの中央に新しいオブジェクトとして追加されます。
プロパティパネル (Properties)
シーン上のオブジェクトをクリックして選択すると、そのオブジェクトの詳細なプロパティが表示され、リアルタイムに編集できます。
Export Layout: シーンの現在の状態（全オブジェクトの配置、プロパティ、レイヤー情報）を.json形式でクリップボードにコピーします。これをassets/data/scenes/フォルダ内の対応するJSONファイルに貼り付けることで、変更が保存されます。
Name: オブジェクトの固有の名前です。VSLタグからtargetとして指定する際に使います。必ずユニークな名前を付けてください。
Group: オブジェクトが所属する「チーム名」です。イベントの対象をグループで指定する際に使います（後述）。
Transform: 位置(x, y)、拡大率(scale)、角度(angle)、透明度(alpha)、表示順(depth)など、見た目に関する設定です。
物理ボディ (Physics): オブジェクトに物理的な実体を与えるための設定です。

6. オブジェクトの「正体」を決める：グループと物理の大切な話
Odyssey Engineでは、シーンに置かれたすべてのオブジェクトに、2つの大切な「正体」を与えることができます。それは**「グループ（仲間）」と「物理（カタさ）」**です。この2つを理解すると、あなたのゲームの世界はもっと豊かになります。

6.1. オブジェクトグループ：誰の「仲間」なのか？
group（グループ）は、オブジェクトに付ける**「あだな」や「チーム名」**のようなものです。

目的:
エディタで、同じ仲間のオブジェクトをまとめて選択・移動するため。（床タイルをダブルタップで全部選択するなど）
イベントエディタで、**「誰と出会ったら、何が起きるか」**という物語のルールを作るため。
考え方:
「このコインは『coin』という仲間」
「この敵スライムは『enemies』というチーム」
「このドアは『exit_door』という役割」
設定場所: プロパティパネルのGroup入力欄
例：「コインに触れたらスコアが100点アップする」イベントを作る

コインのオブジェクトを選択し、Group入力欄に coin と名付けます。
プレイヤーのオブジェクトを選択し、イベントエディタを開きます。
「イベントを追加」し、以下のように設定します。
トリガー: onOverlap_Start（触れた瞬間）
相手のグループ: coin（"coin"という仲間に触れたら）
アクション: [set_data name=score value="f.score + 100"][destroy target=other]（スコアを100点増やして、触れた相手（コイン）を消す）
このように、groupは**ゲームの物語やルールを作るための、とても大切な「名前」**なのです。

6.2. 物理設定：どれくらい「カタイ」のか？
物理パネルにある設定は、オブジェクトの**「カタさ」や「世界の法則への従い方」**を決めます。これは、物理エンジンという、世界の法則を計算してくれる専門家への指示書のようなものです。

目的:
キャラクターが床の上に乗れるか、壁を通り抜けられないようにするため。
弾が敵には当たるけれど、アイテムはすり抜ける、といった細かいルールを作るため。
考え方:
「この床タイルは、カベと同じくらいカタイ存在」
「このコインは、プレイヤーが触れられるように、フワフワした存在」
「このオバケは、カベをすり抜ける特別な存在」
設定場所: プロパティパネルの物理ボディセクション
2つの大切な物理設定
Category (カテゴリ):
これは、オブジェクトの**「種族」**のようなものです。「あなたはプレイヤー族ですよ」「あなたはカベ族ですよ」と、そのオブジェクトの物理的な正体を決めます。
Collides With (衝突する相手):
これは、そのオブジェクトが**「どの種族とぶつかるか」**を決める設定です。たくさんのチェックボックスが並んでおり、ぶつかってほしい相手の種族にチェックを入れていくだけです。
例：「プレイヤー」オブジェクトの物理設定

プレイヤーを選択し、物理パネルを開きます。
Categoryのドロップダウンからplayerを選びます。（これで彼の種族はplayerになりました）
Collides Withの項目で、wall（カベ）、enemy（敵）、item（アイテム）の3つにチェックを入れます。（これで彼は、カベと敵とアイテムにぶつかるようになります）
例：「プレイヤーの弾」オブジェクトの物理設定

弾を選択し、物理パネルを開きます。
Categoryからplayer_bulletを選びます。
Collides Withで、wall（カベ）とenemy（敵）だけにチェックを入れます。（これで弾は、アイテムをすり抜け、プレイヤー自身にも当たらなくなります）
まとめ：2つの「正体」の使い分け
設定項目	何を決めるか？	一言でいうと	ユースケースの例
オブジェクトグループ	誰の仲間か？	イベントの宛名	coin グループに触れたら、スコアが上がる
物理カテゴリ	どんなカタさか？	衝突のルール	player は wall とは衝突するが、item はすり抜ける

この2つを使いこなせば、「enemies（敵）グループのオブジェクトは、player_bullet（プレイヤーの弾）カテゴリのオブジェクトと衝突し、衝突したら[destroy target=self]（自爆する）イベントが起きる」といった、豊かでインタラクティブな世界を、あなたの手で創造することができます。

7. UIを「生きた」ものにする：コンポーネントシステム入門
これまでのUIは、いわば美しい「絵」でした。しかし、Odyssey Engineの真の力は、UIを単なる絵から、ゲーム世界の出来事にリアルタイムで反応する**「生きた窓」**へと変えることにあります。

それを実現するのがコンポーネントシステムです。

コンポーネントとは、「機能」だけを持つ、目に見えない小さな部品です。エディタ上で、UIオブジェクト（画像やテキスト）にこれらの部品を組み合わせ（アタッチし）ていくことで、プログラミングを一切することなく、HPバーやスコア表示のような動的なUIを自由に作成できます。

7.1. 基本的な考え方：「器」と「神経」と「筋肉」
動的なUIは、3種類の要素の組み合わせで考えます。

器 (GameObject): 見た目そのものです。アセットブラウザから追加した画像やテキストがこれにあたります。
神経 (WatchVariableComponent): ゲーム内の変数を監視し、変化があったら「値が変わったよ！」という信号（イベント）を発信する、目に見えない部品です。
筋肉/声 (DisplayComponent): 神経からの信号を受け取り、器の見た目（幅、テキストなど）を実際に変化させる部品です。
この3つをエディタで組み合わせることで、UIは命を吹き込まれます。

7.2. コンポーネント・リファレンス
プロパティパネルの「Component」セクションから、UIオブジェクトに以下のコンポーネントをアタッチできます。

<h4><code>[WatchVariableComponent]</code> - 神経</h4>
<p>UIに、特定のゲーム変数を監視させるための、最も重要なコンポーネントです。これ単体では見た目は何も変わりませんが、他の表示系コンポーネントと連携するための「神経」として機能します。</p>
<p>アタッチすると、以下のパラメータを編集できます。</p>
<ul>
<li><strong>監視する変数 (f.)</strong> (必須): どのゲーム変数の変化を監視するかを指定します。必ず<code>f.</code>から始まる形式で記述してください。
<ul>
<li>例: <code>f.player_hp</code>, <code>f.score</code>, <code>f.amunition_count</code></li>
</ul>
</li>
</ul>
<p><strong>注意:</strong> 指定した変数（例: <code>f.player_hp</code>）が存在しない、または一度も値が設定されていない場合、このコンポーネントは信号を発信しません。エラーにはなりませんが、UIは変化しないのでご注意ください。</p>
<h4><code>[BarDisplayComponent]</code> - 筋肉（バー表示）</h4>
<p>主に画像オブジェクトにアタッチし、HPバーや経験値バーのように機能させます。神経（<code>WatchVariableComponent</code>）から「値が変わった」という信号を受け取ると、自身の横幅のスケール（<code>scaleX</code>）を、最大値に対する割合に応じて自動で変更します。</p>
<p><strong>前提条件:</strong> このコンポーネントを機能させるには、同じオブジェクトに<code>WatchVariableComponent</code>もアタッチしておく必要があります。</p>
<p>アタッチすると、以下のパラメータを編集できます。</p>
<ul>
<li><strong>最大値の変数 (f.)</strong> (必須): バーが満タン（100%）の時の値を、どのゲーム変数から取得するか指定します。
<ul>
<li>例: <code>f.player_max_hp</code>, <code>f.next_level_exp</code></li>
</ul>
</li>
</ul>
<h4><code>[TextDisplayComponent]</code> - 声（テキスト表示）</h4>
<p>テキストオブジェクトにアタッチし、スコアや残りHPなどを数値として表示させます。神経（<code>WatchVariableComponent</code>）から「値が変わった」という信号を受け取ると、自身のテキスト内容を、指定されたテンプレートに従って自動で更新します。</p>
<p><strong>前提条件:</strong> このコンポーネントを機能させるには、同じオブジェクトに<code>WatchVariableComponent</code>もアタッチしておく必要があります。</p>
<p>アタッチすると、以下のパラメータを編集できます。</p>
<ul>
<li><strong>表示テンプレート</strong> (必須): どのようにテキストを表示するかの書式を指定します。特別なキーワード<code>{value}</code>が、神経から受け取った実際の値に自動的に置き換えられます。
<ul>
<li>例: <code>SCORE: {value}</code> → SCORE: 100</li>
<li>例: <code>HP: {value}</code> → HP: 85</li>
<li>例: <code>{value} / 100</code> → 85 / 100</li>
<li>例: <code>{value}</code> → 85</li>
</ul>
</li>
</ul>
7.3. 実践チュートリアル：動くHPバーを作ってみよう
器を準備する: アセットブラウザからHPバーの「中身」の画像（例: hp_bar_fill.png）をシーンに追加します。名前を'player_hp_bar_fill'などに変更します。
神経を繋ぐ:
player_hp_bar_fillを選択し、プロパティパネルで「Add Component」をクリックし、WatchVariableComponentを選択します。
表示された入力欄「監視する変数 (f.)」に、**f.player_hp**と入力します。
筋肉を繋ぐ:
再度「Add Component」をクリックし、今度はBarDisplayComponentを選択します。
表示された入力欄「最大値の変数 (f.)」に、**f.player_max_hp**と入力します。
（任意）背景を置く: HPバーの「枠」の画像（例: hp_bar_frame.png）をシーンに追加し、depthを調整してplayer_hp_bar_fillのすぐ後ろに配置します。
テストする: シナリオやイベントで[eval exp="f.player_hp = 50"]のようなタグを実行すると、HPバーの表示が半分になるはずです。

コンポーネントの中でも最も強力なのがStateMachineComponentです。これは、オブジェクトに**「状態」**という概念を与え、複雑なAIや振る舞いをプログラミング無しで実装するための魂です。

アタッチ: プロパティパネルのコンポーネント追加からStateMachineComponentを追加します。
編集: 「ステートマシン・エディタを開く」ボタンを押して、専用のエディタを開きます。
ステートマシンエディタの使い方

状態リスト (左ペイン): オブジェクトが取りうる「状態」（例: 待機, 追跡, 攻撃, 気絶）を管理します。「＋」ボタンで新しい状態を追加できます。
イベントフック (右ペイン上部): 選択した状態が持つ3つのライフサイクルイベントです。
onEnter (実行時): その状態になった瞬間に一度だけ実行されます。
onUpdate (更新時): その状態であり続ける間、毎フレーム実行されます。
onExit (終了時): その状態から別の状態に移る瞬間に一度だけ実行されます。
VSLエディタ (右ペイン中央): 各フックで実行されるロジックを、お馴染みのVSL（ビジュアルスクリプト）で組みます。
実践チュートリアル：近づくと逃げるキャラクターを作ってみよう

シーンにオブジェクトを2つ配置し、それぞれ名前をPlayerとScaredyCatにします。両方に物理ボディを付与します。
ScaredyCatを選択し、StateMachineComponentをアタッチしてエディタを開きます。
逃走中(Fleeing)という新しい状態を追加します。
待機状態のonUpdateフックに、以下のVSLを組みます。
[distance_check target_b="Player" distance="200"]
distance_checkのoutput_nearピンから[state_transition to="逃走中"]に接続します。
逃走中状態のonUpdateフックに、以下のVSLを組みます。
[apply_force x="'(source.x > target.x ? 1 : -1) * 0.01'" target="source"] (プレイヤーから離れる方向に力を加える)
上記ノードのoutputから[distance_check target_b="Player" distance="400"]に接続します。
distance_checkのoutput_farピンから[state_transition to="待機"]に接続します。
プレイモードで確認します。Playerが近づくとScaredyCatが逃げ出し、十分に離れると止まるはずです。



このマニュアルが、あなたの創造の旅の信頼できる羅針盤となることを願っています。
さあ、あなただけの物語を始めましょう！
